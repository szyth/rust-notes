- Generic types allows us to replace specific types with a placeholder that represents multiple types to remove code duplication.
- Generic types of Rust are similar to `any` type of Typescript.
- Functions can take parameters of some generic type, instead of a concrete type like `i32` or `String`.
- Eg: `Option<T>`, `Vec<T>`, `HashMap<K, V>`, `Result<T, E>`, etc
----
- We’ll learn how to use _traits_ to define behavior in a generic way. We can combine traits with generic types to constrain a generic type to accept only those types that have a particular behavior, as opposed to just any type.
	- We'll create a program next that returns the Max value in an array. The array can be of any type `int`, `char`,etc using Generics
- we’ll discuss _lifetimes_: a variety of generics that give the compiler information about how references relate to each other. Lifetimes allow us to give the compiler enough information about borrowed values so that it can ensure references will be valid in more situations than it could without our help.